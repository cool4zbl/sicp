## Solution (Exersise 1.5)
*in Chinese*

关键是 `(define (p) (p))` 定义了一个 自己调用自己 的函数.

使用 **applicative-order** 的解释器会
先计算所有的 `arguments`, 再 apply.
所以当执行到 `(test 0 (p))`, 先开始算 `0`, 然后会尝试算 `(p)`.

当开始算 `(p)` 的时候，解释器会:
1. 用对应的实参替换过程 body 中所有的形参, 这里没有形参，所以 过程体就是 `(p)`;
2. 计算过程 body, 也就是这里的 `(p)`, 这样就造成这玩意开始不断重复地调用自己，最后变成 无限循环.


使用 **normal-order** 的解释器会
先整个展开所有的 operator(运算符), 再进行 reduce.
所以，在需要那些 operands(运算对象) 的值以前，解释器都不会先去计算它们.

`(test 0 (p))`
=>
`(if (= 0 0))
      0
      (p))`

=>
`0`

